// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STOREINFODATA_JOESCAN_SCHEMA_CLIENT_H_
#define FLATBUFFERS_GENERATED_STOREINFODATA_JOESCAN_SCHEMA_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

#include "MessageClientEnums_generated.h"

namespace joescan {
namespace schema {
namespace client {

struct StoreAlignmentData;
struct StoreAlignmentDataBuilder;
struct StoreAlignmentDataT;

struct StoreMappleCorrectionData;
struct StoreMappleCorrectionDataBuilder;
struct StoreMappleCorrectionDataT;

struct StoreInfoData;
struct StoreInfoDataBuilder;
struct StoreInfoDataT;

enum StoreType : uint16_t {
  StoreType_ALIGNMENT = 0,
  StoreType_MAPPLE_CORRECTION = 1,
  StoreType_MIN = StoreType_ALIGNMENT,
  StoreType_MAX = StoreType_MAPPLE_CORRECTION
};

inline const StoreType (&EnumValuesStoreType())[2] {
  static const StoreType values[] = {
    StoreType_ALIGNMENT,
    StoreType_MAPPLE_CORRECTION
  };
  return values;
}

inline const char * const *EnumNamesStoreType() {
  static const char * const names[3] = {
    "ALIGNMENT",
    "MAPPLE_CORRECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameStoreType(StoreType e) {
  if (flatbuffers::IsOutRange(e, StoreType_ALIGNMENT, StoreType_MAPPLE_CORRECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStoreType()[index];
}

enum StoreData : uint8_t {
  StoreData_NONE = 0,
  StoreData_StoreAlignmentData = 1,
  StoreData_StoreMappleCorrectionData = 2,
  StoreData_MIN = StoreData_NONE,
  StoreData_MAX = StoreData_StoreMappleCorrectionData
};

inline const StoreData (&EnumValuesStoreData())[3] {
  static const StoreData values[] = {
    StoreData_NONE,
    StoreData_StoreAlignmentData,
    StoreData_StoreMappleCorrectionData
  };
  return values;
}

inline const char * const *EnumNamesStoreData() {
  static const char * const names[4] = {
    "NONE",
    "StoreAlignmentData",
    "StoreMappleCorrectionData",
    nullptr
  };
  return names;
}

inline const char *EnumNameStoreData(StoreData e) {
  if (flatbuffers::IsOutRange(e, StoreData_NONE, StoreData_StoreMappleCorrectionData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStoreData()[index];
}

template<typename T> struct StoreDataTraits {
  static const StoreData enum_value = StoreData_NONE;
};

template<> struct StoreDataTraits<joescan::schema::client::StoreAlignmentData> {
  static const StoreData enum_value = StoreData_StoreAlignmentData;
};

template<> struct StoreDataTraits<joescan::schema::client::StoreMappleCorrectionData> {
  static const StoreData enum_value = StoreData_StoreMappleCorrectionData;
};

struct StoreDataUnion {
  StoreData type;
  void *value;

  StoreDataUnion() : type(StoreData_NONE), value(nullptr) {}
  StoreDataUnion(StoreDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(StoreData_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  StoreDataUnion(const StoreDataUnion &);
  StoreDataUnion &operator=(const StoreDataUnion &u)
    { StoreDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  StoreDataUnion &operator=(StoreDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~StoreDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = StoreDataTraits<typename RT::TableType>::enum_value;
    if (type != StoreData_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, StoreData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  joescan::schema::client::StoreAlignmentDataT *AsStoreAlignmentData() {
    return type == StoreData_StoreAlignmentData ?
      reinterpret_cast<joescan::schema::client::StoreAlignmentDataT *>(value) : nullptr;
  }
  const joescan::schema::client::StoreAlignmentDataT *AsStoreAlignmentData() const {
    return type == StoreData_StoreAlignmentData ?
      reinterpret_cast<const joescan::schema::client::StoreAlignmentDataT *>(value) : nullptr;
  }
  joescan::schema::client::StoreMappleCorrectionDataT *AsStoreMappleCorrectionData() {
    return type == StoreData_StoreMappleCorrectionData ?
      reinterpret_cast<joescan::schema::client::StoreMappleCorrectionDataT *>(value) : nullptr;
  }
  const joescan::schema::client::StoreMappleCorrectionDataT *AsStoreMappleCorrectionData() const {
    return type == StoreData_StoreMappleCorrectionData ?
      reinterpret_cast<const joescan::schema::client::StoreMappleCorrectionDataT *>(value) : nullptr;
  }
};

bool VerifyStoreData(flatbuffers::Verifier &verifier, const void *obj, StoreData type);
bool VerifyStoreDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StoreAlignmentDataT : public flatbuffers::NativeTable {
  typedef StoreAlignmentData TableType;
  joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  double x_offset = 0.0;
  double y_offset = 0.0;
  double roll = 0.0;
  float fit_error = 0.0f;
};

struct StoreAlignmentData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StoreAlignmentDataT NativeTableType;
  typedef StoreAlignmentDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_ORIENTATION = 4,
    VT_CAMERA_PORT = 6,
    VT_LASER_PORT = 8,
    VT_X_OFFSET = 10,
    VT_Y_OFFSET = 12,
    VT_ROLL = 14,
    VT_FIT_ERROR = 16
  };
  joescan::schema::client::CameraOrientation camera_orientation() const {
    return static_cast<joescan::schema::client::CameraOrientation>(GetField<uint16_t>(VT_CAMERA_ORIENTATION, 0));
  }
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  double x_offset() const {
    return GetField<double>(VT_X_OFFSET, 0.0);
  }
  double y_offset() const {
    return GetField<double>(VT_Y_OFFSET, 0.0);
  }
  double roll() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  float fit_error() const {
    return GetField<float>(VT_FIT_ERROR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CAMERA_ORIENTATION) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<double>(verifier, VT_X_OFFSET) &&
           VerifyField<double>(verifier, VT_Y_OFFSET) &&
           VerifyField<double>(verifier, VT_ROLL) &&
           VerifyField<float>(verifier, VT_FIT_ERROR) &&
           verifier.EndTable();
  }
  StoreAlignmentDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoreAlignmentDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StoreAlignmentData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreAlignmentDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoreAlignmentDataBuilder {
  typedef StoreAlignmentData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_orientation(joescan::schema::client::CameraOrientation camera_orientation) {
    fbb_.AddElement<uint16_t>(StoreAlignmentData::VT_CAMERA_ORIENTATION, static_cast<uint16_t>(camera_orientation), 0);
  }
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(StoreAlignmentData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(StoreAlignmentData::VT_LASER_PORT, laser_port, 0);
  }
  void add_x_offset(double x_offset) {
    fbb_.AddElement<double>(StoreAlignmentData::VT_X_OFFSET, x_offset, 0.0);
  }
  void add_y_offset(double y_offset) {
    fbb_.AddElement<double>(StoreAlignmentData::VT_Y_OFFSET, y_offset, 0.0);
  }
  void add_roll(double roll) {
    fbb_.AddElement<double>(StoreAlignmentData::VT_ROLL, roll, 0.0);
  }
  void add_fit_error(float fit_error) {
    fbb_.AddElement<float>(StoreAlignmentData::VT_FIT_ERROR, fit_error, 0.0f);
  }
  explicit StoreAlignmentDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StoreAlignmentData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StoreAlignmentData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StoreAlignmentData> CreateStoreAlignmentData(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    double x_offset = 0.0,
    double y_offset = 0.0,
    double roll = 0.0,
    float fit_error = 0.0f) {
  StoreAlignmentDataBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_y_offset(y_offset);
  builder_.add_x_offset(x_offset);
  builder_.add_fit_error(fit_error);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  builder_.add_camera_orientation(camera_orientation);
  return builder_.Finish();
}

flatbuffers::Offset<StoreAlignmentData> CreateStoreAlignmentData(flatbuffers::FlatBufferBuilder &_fbb, const StoreAlignmentDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoreMappleCorrectionDataT : public flatbuffers::NativeTable {
  typedef StoreMappleCorrectionData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  double x_offset = 0.0;
  double y_offset = 0.0;
  double roll = 0.0;
  float fit_error = 0.0f;
};

struct StoreMappleCorrectionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StoreMappleCorrectionDataT NativeTableType;
  typedef StoreMappleCorrectionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_X_OFFSET = 8,
    VT_Y_OFFSET = 10,
    VT_ROLL = 12,
    VT_FIT_ERROR = 14
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  double x_offset() const {
    return GetField<double>(VT_X_OFFSET, 0.0);
  }
  double y_offset() const {
    return GetField<double>(VT_Y_OFFSET, 0.0);
  }
  double roll() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  float fit_error() const {
    return GetField<float>(VT_FIT_ERROR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<double>(verifier, VT_X_OFFSET) &&
           VerifyField<double>(verifier, VT_Y_OFFSET) &&
           VerifyField<double>(verifier, VT_ROLL) &&
           VerifyField<float>(verifier, VT_FIT_ERROR) &&
           verifier.EndTable();
  }
  StoreMappleCorrectionDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoreMappleCorrectionDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StoreMappleCorrectionData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreMappleCorrectionDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoreMappleCorrectionDataBuilder {
  typedef StoreMappleCorrectionData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(StoreMappleCorrectionData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(StoreMappleCorrectionData::VT_LASER_PORT, laser_port, 0);
  }
  void add_x_offset(double x_offset) {
    fbb_.AddElement<double>(StoreMappleCorrectionData::VT_X_OFFSET, x_offset, 0.0);
  }
  void add_y_offset(double y_offset) {
    fbb_.AddElement<double>(StoreMappleCorrectionData::VT_Y_OFFSET, y_offset, 0.0);
  }
  void add_roll(double roll) {
    fbb_.AddElement<double>(StoreMappleCorrectionData::VT_ROLL, roll, 0.0);
  }
  void add_fit_error(float fit_error) {
    fbb_.AddElement<float>(StoreMappleCorrectionData::VT_FIT_ERROR, fit_error, 0.0f);
  }
  explicit StoreMappleCorrectionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StoreMappleCorrectionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StoreMappleCorrectionData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StoreMappleCorrectionData> CreateStoreMappleCorrectionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    double x_offset = 0.0,
    double y_offset = 0.0,
    double roll = 0.0,
    float fit_error = 0.0f) {
  StoreMappleCorrectionDataBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_y_offset(y_offset);
  builder_.add_x_offset(x_offset);
  builder_.add_fit_error(fit_error);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

flatbuffers::Offset<StoreMappleCorrectionData> CreateStoreMappleCorrectionData(flatbuffers::FlatBufferBuilder &_fbb, const StoreMappleCorrectionDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoreInfoDataT : public flatbuffers::NativeTable {
  typedef StoreInfoData TableType;
  int64_t timestamp_s = 0;
  std::vector<std::string> notes{};
  joescan::schema::client::StoreType type = joescan::schema::client::StoreType_ALIGNMENT;
  joescan::schema::client::StoreDataUnion data{};
};

struct StoreInfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StoreInfoDataT NativeTableType;
  typedef StoreInfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_S = 4,
    VT_NOTES = 6,
    VT_TYPE = 8,
    VT_DATA_TYPE = 10,
    VT_DATA = 12
  };
  int64_t timestamp_s() const {
    return GetField<int64_t>(VT_TIMESTAMP_S, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *notes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NOTES);
  }
  joescan::schema::client::StoreType type() const {
    return static_cast<joescan::schema::client::StoreType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  joescan::schema::client::StoreData data_type() const {
    return static_cast<joescan::schema::client::StoreData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const joescan::schema::client::StoreAlignmentData *data_as_StoreAlignmentData() const {
    return data_type() == joescan::schema::client::StoreData_StoreAlignmentData ? static_cast<const joescan::schema::client::StoreAlignmentData *>(data()) : nullptr;
  }
  const joescan::schema::client::StoreMappleCorrectionData *data_as_StoreMappleCorrectionData() const {
    return data_type() == joescan::schema::client::StoreData_StoreMappleCorrectionData ? static_cast<const joescan::schema::client::StoreMappleCorrectionData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP_S) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyVector(notes()) &&
           verifier.VerifyVectorOfStrings(notes()) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyStoreData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  StoreInfoDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoreInfoDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StoreInfoData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreInfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const joescan::schema::client::StoreAlignmentData *StoreInfoData::data_as<joescan::schema::client::StoreAlignmentData>() const {
  return data_as_StoreAlignmentData();
}

template<> inline const joescan::schema::client::StoreMappleCorrectionData *StoreInfoData::data_as<joescan::schema::client::StoreMappleCorrectionData>() const {
  return data_as_StoreMappleCorrectionData();
}

struct StoreInfoDataBuilder {
  typedef StoreInfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp_s(int64_t timestamp_s) {
    fbb_.AddElement<int64_t>(StoreInfoData::VT_TIMESTAMP_S, timestamp_s, 0);
  }
  void add_notes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> notes) {
    fbb_.AddOffset(StoreInfoData::VT_NOTES, notes);
  }
  void add_type(joescan::schema::client::StoreType type) {
    fbb_.AddElement<uint16_t>(StoreInfoData::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data_type(joescan::schema::client::StoreData data_type) {
    fbb_.AddElement<uint8_t>(StoreInfoData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(StoreInfoData::VT_DATA, data);
  }
  explicit StoreInfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StoreInfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StoreInfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StoreInfoData> CreateStoreInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp_s = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> notes = 0,
    joescan::schema::client::StoreType type = joescan::schema::client::StoreType_ALIGNMENT,
    joescan::schema::client::StoreData data_type = joescan::schema::client::StoreData_NONE,
    flatbuffers::Offset<void> data = 0) {
  StoreInfoDataBuilder builder_(_fbb);
  builder_.add_timestamp_s(timestamp_s);
  builder_.add_data(data);
  builder_.add_notes(notes);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StoreInfoData> CreateStoreInfoDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp_s = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *notes = nullptr,
    joescan::schema::client::StoreType type = joescan::schema::client::StoreType_ALIGNMENT,
    joescan::schema::client::StoreData data_type = joescan::schema::client::StoreData_NONE,
    flatbuffers::Offset<void> data = 0) {
  auto notes__ = notes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*notes) : 0;
  return joescan::schema::client::CreateStoreInfoData(
      _fbb,
      timestamp_s,
      notes__,
      type,
      data_type,
      data);
}

flatbuffers::Offset<StoreInfoData> CreateStoreInfoData(flatbuffers::FlatBufferBuilder &_fbb, const StoreInfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StoreAlignmentDataT *StoreAlignmentData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StoreAlignmentDataT>(new StoreAlignmentDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StoreAlignmentData::UnPackTo(StoreAlignmentDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_orientation(); _o->camera_orientation = _e; }
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = x_offset(); _o->x_offset = _e; }
  { auto _e = y_offset(); _o->y_offset = _e; }
  { auto _e = roll(); _o->roll = _e; }
  { auto _e = fit_error(); _o->fit_error = _e; }
}

inline flatbuffers::Offset<StoreAlignmentData> StoreAlignmentData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreAlignmentDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStoreAlignmentData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StoreAlignmentData> CreateStoreAlignmentData(flatbuffers::FlatBufferBuilder &_fbb, const StoreAlignmentDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StoreAlignmentDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_orientation = _o->camera_orientation;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _x_offset = _o->x_offset;
  auto _y_offset = _o->y_offset;
  auto _roll = _o->roll;
  auto _fit_error = _o->fit_error;
  return joescan::schema::client::CreateStoreAlignmentData(
      _fbb,
      _camera_orientation,
      _camera_port,
      _laser_port,
      _x_offset,
      _y_offset,
      _roll,
      _fit_error);
}

inline StoreMappleCorrectionDataT *StoreMappleCorrectionData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StoreMappleCorrectionDataT>(new StoreMappleCorrectionDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StoreMappleCorrectionData::UnPackTo(StoreMappleCorrectionDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = x_offset(); _o->x_offset = _e; }
  { auto _e = y_offset(); _o->y_offset = _e; }
  { auto _e = roll(); _o->roll = _e; }
  { auto _e = fit_error(); _o->fit_error = _e; }
}

inline flatbuffers::Offset<StoreMappleCorrectionData> StoreMappleCorrectionData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreMappleCorrectionDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStoreMappleCorrectionData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StoreMappleCorrectionData> CreateStoreMappleCorrectionData(flatbuffers::FlatBufferBuilder &_fbb, const StoreMappleCorrectionDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StoreMappleCorrectionDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _x_offset = _o->x_offset;
  auto _y_offset = _o->y_offset;
  auto _roll = _o->roll;
  auto _fit_error = _o->fit_error;
  return joescan::schema::client::CreateStoreMappleCorrectionData(
      _fbb,
      _camera_port,
      _laser_port,
      _x_offset,
      _y_offset,
      _roll,
      _fit_error);
}

inline StoreInfoDataT *StoreInfoData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StoreInfoDataT>(new StoreInfoDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StoreInfoData::UnPackTo(StoreInfoDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp_s(); _o->timestamp_s = _e; }
  { auto _e = notes(); if (_e) { _o->notes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->notes[_i] = _e->Get(_i)->str(); } } }
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = joescan::schema::client::StoreDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<StoreInfoData> StoreInfoData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StoreInfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStoreInfoData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StoreInfoData> CreateStoreInfoData(flatbuffers::FlatBufferBuilder &_fbb, const StoreInfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StoreInfoDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp_s = _o->timestamp_s;
  auto _notes = _o->notes.size() ? _fbb.CreateVectorOfStrings(_o->notes) : 0;
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return joescan::schema::client::CreateStoreInfoData(
      _fbb,
      _timestamp_s,
      _notes,
      _type,
      _data_type,
      _data);
}

inline bool VerifyStoreData(flatbuffers::Verifier &verifier, const void *obj, StoreData type) {
  switch (type) {
    case StoreData_NONE: {
      return true;
    }
    case StoreData_StoreAlignmentData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreAlignmentData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StoreData_StoreMappleCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreMappleCorrectionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyStoreDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStoreData(
        verifier,  values->Get(i), types->GetEnum<StoreData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *StoreDataUnion::UnPack(const void *obj, StoreData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case StoreData_StoreAlignmentData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreAlignmentData *>(obj);
      return ptr->UnPack(resolver);
    }
    case StoreData_StoreMappleCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreMappleCorrectionData *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> StoreDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case StoreData_StoreAlignmentData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreAlignmentDataT *>(value);
      return CreateStoreAlignmentData(_fbb, ptr, _rehasher).Union();
    }
    case StoreData_StoreMappleCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::StoreMappleCorrectionDataT *>(value);
      return CreateStoreMappleCorrectionData(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline StoreDataUnion::StoreDataUnion(const StoreDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case StoreData_StoreAlignmentData: {
      value = new joescan::schema::client::StoreAlignmentDataT(*reinterpret_cast<joescan::schema::client::StoreAlignmentDataT *>(u.value));
      break;
    }
    case StoreData_StoreMappleCorrectionData: {
      value = new joescan::schema::client::StoreMappleCorrectionDataT(*reinterpret_cast<joescan::schema::client::StoreMappleCorrectionDataT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void StoreDataUnion::Reset() {
  switch (type) {
    case StoreData_StoreAlignmentData: {
      auto ptr = reinterpret_cast<joescan::schema::client::StoreAlignmentDataT *>(value);
      delete ptr;
      break;
    }
    case StoreData_StoreMappleCorrectionData: {
      auto ptr = reinterpret_cast<joescan::schema::client::StoreMappleCorrectionDataT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = StoreData_NONE;
}

}  // namespace client
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_STOREINFODATA_JOESCAN_SCHEMA_CLIENT_H_
