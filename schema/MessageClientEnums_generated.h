// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGECLIENTENUMS_JOESCAN_SCHEMA_CLIENT_H_
#define FLATBUFFERS_GENERATED_MESSAGECLIENTENUMS_JOESCAN_SCHEMA_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

namespace joescan {
namespace schema {
namespace client {

enum ConnectionType : uint16_t {
  ConnectionType_NORMAL = 0,
  ConnectionType_MAPPLER = 1,
  ConnectionType_MIN = ConnectionType_NORMAL,
  ConnectionType_MAX = ConnectionType_MAPPLER
};

inline const ConnectionType (&EnumValuesConnectionType())[2] {
  static const ConnectionType values[] = {
    ConnectionType_NORMAL,
    ConnectionType_MAPPLER
  };
  return values;
}

inline const char * const *EnumNamesConnectionType() {
  static const char * const names[3] = {
    "NORMAL",
    "MAPPLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionType(ConnectionType e) {
  if (flatbuffers::IsOutRange(e, ConnectionType_NORMAL, ConnectionType_MAPPLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionType()[index];
}

enum CameraOrientation : uint16_t {
  CameraOrientation_UPSTREAM = 0,
  CameraOrientation_DOWNSTREAM = 1,
  CameraOrientation_MIN = CameraOrientation_UPSTREAM,
  CameraOrientation_MAX = CameraOrientation_DOWNSTREAM
};

inline const CameraOrientation (&EnumValuesCameraOrientation())[2] {
  static const CameraOrientation values[] = {
    CameraOrientation_UPSTREAM,
    CameraOrientation_DOWNSTREAM
  };
  return values;
}

inline const char * const *EnumNamesCameraOrientation() {
  static const char * const names[3] = {
    "UPSTREAM",
    "DOWNSTREAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameCameraOrientation(CameraOrientation e) {
  if (flatbuffers::IsOutRange(e, CameraOrientation_UPSTREAM, CameraOrientation_DOWNSTREAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCameraOrientation()[index];
}

enum ImageDataType : uint16_t {
  ImageDataType_MERGED_MASK_IMAGE = 0,
  ImageDataType_RAW_IMAGE = 1,
  ImageDataType_MIN = ImageDataType_MERGED_MASK_IMAGE,
  ImageDataType_MAX = ImageDataType_RAW_IMAGE
};

inline const ImageDataType (&EnumValuesImageDataType())[2] {
  static const ImageDataType values[] = {
    ImageDataType_MERGED_MASK_IMAGE,
    ImageDataType_RAW_IMAGE
  };
  return values;
}

inline const char * const *EnumNamesImageDataType() {
  static const char * const names[3] = {
    "MERGED_MASK_IMAGE",
    "RAW_IMAGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameImageDataType(ImageDataType e) {
  if (flatbuffers::IsOutRange(e, ImageDataType_MERGED_MASK_IMAGE, ImageDataType_RAW_IMAGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImageDataType()[index];
}

}  // namespace client
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGECLIENTENUMS_JOESCAN_SCHEMA_CLIENT_H_
