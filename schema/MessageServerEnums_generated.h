// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGESERVERENUMS_JOESCAN_SCHEMA_SERVER_H_
#define FLATBUFFERS_GENERATED_MESSAGESERVERENUMS_JOESCAN_SCHEMA_SERVER_H_

#include "flatbuffers/flatbuffers.h"

namespace joescan {
namespace schema {
namespace server {

enum ScanHeadState : uint16_t {
  ScanHeadState_INVALID = 0,
  ScanHeadState_STANDBY = 1,
  ScanHeadState_CONNECTED = 2,
  ScanHeadState_SCANNING = 3,
  ScanHeadState_SCANNING_IDLE = 4,
  ScanHeadState_MIN = ScanHeadState_INVALID,
  ScanHeadState_MAX = ScanHeadState_SCANNING_IDLE
};

inline const ScanHeadState (&EnumValuesScanHeadState())[5] {
  static const ScanHeadState values[] = {
    ScanHeadState_INVALID,
    ScanHeadState_STANDBY,
    ScanHeadState_CONNECTED,
    ScanHeadState_SCANNING,
    ScanHeadState_SCANNING_IDLE
  };
  return values;
}

inline const char * const *EnumNamesScanHeadState() {
  static const char * const names[6] = {
    "INVALID",
    "STANDBY",
    "CONNECTED",
    "SCANNING",
    "SCANNING_IDLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameScanHeadState(ScanHeadState e) {
  if (flatbuffers::IsOutRange(e, ScanHeadState_INVALID, ScanHeadState_SCANNING_IDLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScanHeadState()[index];
}

enum ScanSyncFlags : uint32_t {
  ScanSyncFlags_FAULT_A = 1,
  ScanSyncFlags_FAULT_B = 2,
  ScanSyncFlags_FAULT_Y = 4,
  ScanSyncFlags_FAULT_Z = 8,
  ScanSyncFlags_OVERRUN = 16,
  ScanSyncFlags_TERMINATION_ENABLE = 32,
  ScanSyncFlags_INDEX_Z = 64,
  ScanSyncFlags_SYNC = 128,
  ScanSyncFlags_AUX_Y = 256,
  ScanSyncFlags_FAULT_SYNC = 512,
  ScanSyncFlags_LASER_DISABLE = 1024,
  ScanSyncFlags_FAULT_LASER_DISABLE = 2048,
  ScanSyncFlags_NONE = 0,
  ScanSyncFlags_ANY = 4095
};

inline const ScanSyncFlags (&EnumValuesScanSyncFlags())[12] {
  static const ScanSyncFlags values[] = {
    ScanSyncFlags_FAULT_A,
    ScanSyncFlags_FAULT_B,
    ScanSyncFlags_FAULT_Y,
    ScanSyncFlags_FAULT_Z,
    ScanSyncFlags_OVERRUN,
    ScanSyncFlags_TERMINATION_ENABLE,
    ScanSyncFlags_INDEX_Z,
    ScanSyncFlags_SYNC,
    ScanSyncFlags_AUX_Y,
    ScanSyncFlags_FAULT_SYNC,
    ScanSyncFlags_LASER_DISABLE,
    ScanSyncFlags_FAULT_LASER_DISABLE
  };
  return values;
}

inline const char *EnumNameScanSyncFlags(ScanSyncFlags e) {
  switch (e) {
    case ScanSyncFlags_FAULT_A: return "FAULT_A";
    case ScanSyncFlags_FAULT_B: return "FAULT_B";
    case ScanSyncFlags_FAULT_Y: return "FAULT_Y";
    case ScanSyncFlags_FAULT_Z: return "FAULT_Z";
    case ScanSyncFlags_OVERRUN: return "OVERRUN";
    case ScanSyncFlags_TERMINATION_ENABLE: return "TERMINATION_ENABLE";
    case ScanSyncFlags_INDEX_Z: return "INDEX_Z";
    case ScanSyncFlags_SYNC: return "SYNC";
    case ScanSyncFlags_AUX_Y: return "AUX_Y";
    case ScanSyncFlags_FAULT_SYNC: return "FAULT_SYNC";
    case ScanSyncFlags_LASER_DISABLE: return "LASER_DISABLE";
    case ScanSyncFlags_FAULT_LASER_DISABLE: return "FAULT_LASER_DISABLE";
    default: return "";
  }
}

enum EncoderRole : int16_t {
  EncoderRole_IGNORED = -1,
  EncoderRole_MAIN = 0,
  EncoderRole_AUX_1 = 1,
  EncoderRole_AUX_2 = 2,
  EncoderRole_MIN = EncoderRole_IGNORED,
  EncoderRole_MAX = EncoderRole_AUX_2
};

inline const EncoderRole (&EnumValuesEncoderRole())[4] {
  static const EncoderRole values[] = {
    EncoderRole_IGNORED,
    EncoderRole_MAIN,
    EncoderRole_AUX_1,
    EncoderRole_AUX_2
  };
  return values;
}

inline const char * const *EnumNamesEncoderRole() {
  static const char * const names[5] = {
    "IGNORED",
    "MAIN",
    "AUX_1",
    "AUX_2",
    nullptr
  };
  return names;
}

inline const char *EnumNameEncoderRole(EncoderRole e) {
  if (flatbuffers::IsOutRange(e, EncoderRole_IGNORED, EncoderRole_AUX_2)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EncoderRole_IGNORED);
  return EnumNamesEncoderRole()[index];
}

}  // namespace server
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGESERVERENUMS_JOESCAN_SCHEMA_SERVER_H_
